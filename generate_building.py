import numpy as np

def save_ply(filename, points):
    """
    Saves a numpy array of points (N, 3) to an ASCII PLY file.
    """
    num_points = points.shape[0]
    
    header = f"""ply
format ascii 1.0
comment Generated by Gemini AI - LoD2 Grid Building
element vertex {num_points}
property float x
property float y
property float z
end_header
"""
    
    with open(filename, 'w') as f:
        f.write(header)
        for p in points:
            f.write(f"{p[0]:.4f} {p[1]:.4f} {p[2]:.4f}\n")
    
    print(f"Saved {num_points} points to {filename}")

def generate_block_points(x_offset, y_offset, width=1.0, wall_height=2.0, roof_height=1.0, density=20, roof_type='flat'):
    """
    Generates surface points for a single voxel unit.
    roof_type: 'pyramid' or 'flat'
    """
    points = []
    
    # -----------------------------
    # 1. WALLS (Vertical planes)
    # -----------------------------
    z_vals = np.linspace(0, wall_height, int(wall_height * density))
    w_vals = np.linspace(0, width, int(width * density))
    
    # Front Wall (y = 0)
    for z in z_vals:
        for x in w_vals:
            points.append([x_offset + x, y_offset, z])
            
    # Back Wall (y = width)
    for z in z_vals:
        for x in w_vals:
            points.append([x_offset + x, y_offset + width, z])
            
    # Left Wall (x = 0)
    for z in z_vals:
        for y in w_vals:
            points.append([x_offset, y_offset + y, z])
            
    # Right Wall (x = width)
    for z in z_vals:
        for y in w_vals:
            points.append([x_offset + width, y_offset + y, z])

    # -----------------------------
    # 2. ROOF GENERATION
    # -----------------------------
    if roof_type == 'flat':
        # Just fill the top square at z = wall_height
        for x in w_vals:
            for y in w_vals:
                points.append([x_offset + x, y_offset + y, wall_height])

    elif roof_type == 'hipped':
        # Existing pyramid logic
        steps = int(roof_height * density)
        for i in range(steps + 1):
            t = i / steps
            z = wall_height + (t * roof_height)
            current_w = width * (1 - t)
            offset = (width - current_w) / 2
            
            perimeter_steps = int(current_w * density)
            if perimeter_steps < 1: perimeter_steps = 1
            
            p_vals = np.linspace(0, current_w, perimeter_steps)
            
            for p in p_vals:
                points.append([x_offset + offset + p, y_offset + offset, z])
                points.append([x_offset + offset + p, y_offset + offset + current_w, z])
                points.append([x_offset + offset, y_offset + offset + p, z])
                points.append([x_offset + offset + current_w, y_offset + offset + p, z])

    return points

def generate_ground_points(grid_layout, density=20):
    """
    Generates points at Z=0 strictly within the building's footprint.
    """
    footprint_points = []
    rows, cols = grid_layout.shape
    unit_steps = np.linspace(0, 1.0, density)

    for r in range(rows):
        for c in range(cols):
            if grid_layout[r, c] == 1:
                for x_s in unit_steps:
                    for y_s in unit_steps:
                        footprint_points.append([r + x_s, c + y_s, 0.0])
                
    return footprint_points

def main():
    # --- Configuration ---
    point_density = 30  

    # CHANGE THIS to 'flat' or 'hipped'
    SELECTED_ROOF_TYPE = input("Enter roof type ('flat' or 'hipped'): ").strip().lower() 
    
    # Define Footprint
    grid_layout = np.array([
        [1, 1, 1, 1],
        [1, 0, 0, 1],
        [1, 0, 0, 0],
        [1, 1, 1, 0]
    ])
    
    all_points = []
    
    print("Generating ground...")
    footprint_pts = generate_ground_points(grid_layout, density=point_density)
    all_points.extend(footprint_pts)

    rows, cols = grid_layout.shape
    
    print(f"Generating building with {SELECTED_ROOF_TYPE} roof...")
    for r in range(rows):
        for c in range(cols):
            if grid_layout[r, c] == 1:
                block_pts = generate_block_points(
                    x_offset=r, 
                    y_offset=c, 
                    width=1.0, 
                    wall_height=2.5, 
                    roof_height=1.0, 
                    density=point_density,
                    roof_type=SELECTED_ROOF_TYPE # Passing the new parameter
                )
                all_points.extend(block_pts)
    
    cloud_data = np.array(all_points)
    filename = "lod2_concave_building_{}.ply".format(SELECTED_ROOF_TYPE) # Changed filename
    save_ply(filename, cloud_data)

if __name__ == "__main__":
    main()